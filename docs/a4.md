# Semantic Analysis Design

The Semantic Analysis design stage of the compiler acts in two effective steps: the "environment creation" step (which walks through the AST of each file generated by the previous (lexer/parser/weeder) step of the compiler and transforms their amalgamation into an "Environment") and the "verification" step (which performs the remainder of the semantic analysis defined in this document upon the newly built Environment). The latter step is comprised of each of the sections defined within this document performed simultaneously; though I will refer to each of these steps individually for the purpose of easier clarification of design decisions, this implementation detail should be kept in mind.

## Environment Building

The Environment Building step is straightforward: each AST is traversed and parsed into a ClassEnvironment (or InterfaceEnvironment). A ClassEnvironment is a structured collection of AST Nodes: for any given class, it defines the extends, implements, constructors, methods, fields, et cetera of this class. By parsing each of these chunks of the AST, we can "clean up" the tree to build it into a custom structure and thus make it easier to analyze.

Each of these attributes (ie. attributes on the ClassEnvironment struct) is defined and parsed specially, eg. a ConstructorEnvironment is created which definies the `name`, `modifiers`, `parameters`, and `body` of any given constructor. By creating these specific attribute environments, we can more easily check several restrictions of the JOOS 1W language. For example, using the FieldEnvironments:

```
field_names = [field.name for field in fields]
unique_field_names = set(field_names)
if len(field_names) != len(unique_field_names):
    raise CompilerError('No two fields declared in the same class may have the same name.')
```

We can enforce other name collision restrictions similarly.

This phase of semantic analysis is also responsible for ensuring all inheritance is valid and then applying that inheritance, eg. including superclass attributes in child classes. This allows future steps of semantic analysis to avoid dealing with inheritance. Note that some of the requirements of future phases of semantic analysis are required for succesful inheritance -- though these requirements are described below, they are applied in the process of inheritance.

## Type Linking

The Type Linking step ensures that each type name resolves to a single unambiguous type. We perform this analysis upon the environment built in the previous step.

This phase is carried out by traversing the environment, searching for names. Whenever a name is found, we perform a lookup in the current environment (ie. all classes, current imports, local method parameters, local variable declarations, etc) to find that name -- this allows us to ensure:
- every name can be resolved, and
- every name is unambiguous

Additionally, we check every import to ensure no strict prefixes resolve.

## Hierarchy Checking

This phase of semantic analysis is performed as a simple validation of the environment created in the first step defined in this document. Each of the requirements defined in the documentation can be performed simply once that transformation is applied. Some examples illustrate this well:
- A class must not extend an interface. For each name defined in the list of types a given class extends, look them up and check whether they are a ClassEnvironment or an InterfaceEnvironment.
- The hierarchy must be acyclic. Traverse each class's inheritance hierarchy and ensure no class is repeated.
- A class that contains (declares or inherits) any abstract methods must be abstract. For each class whose `modifiers` does not contain `abstract`, check that each method on that class has `abstract` in its `modifiers`.
- A method must not replace a final method. For each method inherited in the inheritance phase of rebuilding the environment for inheritance, ensure that the method being overriden (the method with the same `name` and `parameters`) does not have the `final` `modifier`.

There is not much to discuss in this section, since each rule is a straightforward of validation of the environment defined in this documentation. Each of these rules maps to a single short function which easily determines their correctness.

## Disambiguation and Linking of Names

This phase is performed similarly to the "Type Linking" phase: here we ensure each name resolves to a single unambiguous entity. Indeed, much of the code from the Type Linking step is reused here.

This disambiguation and linking is performed upon the environment defined in the first section of this document. We perform a simple traversal of that environment and, upon discovering a name, perform a search in the local environment (ie. all classes, current imports, local method parameters, local variable declarations, etc) to find that entity. For the most part, the rules defined in this section are straightforward: if we can not disamiguate we throw an error, otherwise this phase was successful.

The only "gotcha" in this phase is the lack of forward declarations -- this is easily solved, though, by analyzing fields iteratively and adding them to the given class's list of fields only after they have been declared.

## Type Checking

The bulk of the type checking phase is a resursive function upon statements. Each of these statements is analyzed for type correctness in their interactions, eg. for the addition operator we resolve the type of the left-hand side (recurse), resolve the type of the right-hand side (recurse), and ensure throse types are compatible.

Compatibility checking is an involved set of rules defined in the Java Language Specification; this is simple encoded in an `apply_compatibility_check` function which applies those rules and returns the result. Similarly, we have `apply_assignment` and `apply_math`, which use this compatiblity rule to ensure correctness.

The remainder of this phase is a simple validation check, similar to the "Hierarchy Checking" section defined above. Indeed, as an implementation detail, much of this phase is implemented alongside hierarchy checking. Some of the requirements of this section which are implemented as such include:
- A constructor in a class other than java.lang.Object implicitly calls the zero-argument constructor of its superclass. Check that this zero-argument constructor exists.
- Check that the name of a constructor is the same as the name of its enclosing class.

The above and similar are simple checks which do not need to be performed in the recursive manner defined otherwise. Instead, we can simply analyze the current environment in a more straightforward fashion. For the above two examples:
- For every name defined in an inheritance list, resolve that name in accordance with the above and check it has a zero-argument constructor.
- For each constructor in each class, ensure that constructor name is equal to its class's name.

## Reachability Checking

Reachability Checking is the final phase of the semantic analysis step. This is performed in an odd fashion: it is recursive, similar to the Type Checking section above -- in that we run the reachability check functions recursively upon coming across any sub-block -- but within any given block is performed iteratively. In this way, we iterate through method blocks and search for returning or non-terminating statements. These statements are then used to determine reachability of future statements, since returning or non-termination blocks mark future statments as unreachable.

Additionally, this phase is responsible for ensuring each variable is only used once (definitely) initialized. Since this obeys the same ordering (ie. time-sequential) as reachability checking, it can be performed in-sync with the above. This aspect of reachability checking is simple: each variable is defined with an attribute that determines what level of initialization it has (none, partial, definite); if this value is not definite, we throw an error. As an implementation detail, "none" and "partial" (eg. one option in an `if` statement) initialization is treated identically -- since JOOS 1W restricts usage to only definitiely defined values, there is no reason to keep these separate.

## Testing

These phases were tested similarly: every public test case defined for assignments 2 through 4 was copied into the test environment and run through continuous integration testing. This was the bulk of the testing since failures here provided a clear direction for future development. This was mostly performed automatically: the list of test cases which currently are failing on the `master` branch of the project was easily visible and thus useable to determine where future development efforts should be directed.

Additional testing was performed mostly on an as-needed basis: any cases determined to be relevant to compiler correctness but not included in the public tests were created as unique tests and included in the continuous integration. At this point, the continuous integration has thus become an amalgum of: public assignment test cases, bare JOOS grammatical features, "special" unique tests for better feature evaluation, and stdlib tests to ensure that the current stdlib was always compiled correctly.

For development of features, individual (failing) test cases were run repeatedly until a changeset was created which would cause them to pass. At this time, the entire test set was run: if the test set (which validated against public test cases and "special" tests up to and including the current assignment) had fewer failures than the `master` branch, that feature was applied to `master` and submitted to Marmoset (to ensure that the most correct compiler was always submitted and marked).
