use std::fmt;

use error::message::ErrorMessage;

/// An error struct generated by the parser, including the DFA.
pub struct ParserError {
    /// Optional additional argument.
    pub arg: Option<String>,
    /// ErrorMessage
    pub message: ErrorMessage,
    /// `format1`'ed `ParseNode`s for context, added with self.with_nodes()
    pub nodes: Option<String>,
}

impl ParserError {
    /// Constructs a WeederError from an ErrorMessage and (optionally) some
    /// argument.
    pub fn new(message: ErrorMessage, arg: Option<String>) -> ParserError {
        ParserError {
            arg: arg,
            message: message,
            nodes: None,
        }
    }

    /// Add node information to a ParserError. Should be called as late as
    /// possible before printing the error to ensure we have context.
    pub fn with_nodes<T>(mut self, nodes: T) -> ParserError
        where T: IntoIterator,
              <T as IntoIterator>::Item: fmt::Display
    {
        self.nodes = Some(nodes
                              .into_iter()
                              .map(|n| format!("{}", n))
                              .collect::<Vec<_>>()
                              .join("\n"));
        self
    }
}

impl fmt::Display for ParserError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.arg {
            Some(ref r) => {
                match self.nodes {
                    Some(ref n) => write!(f, "error: {}\n{}\n\n{}", self.message, r, n),
                    _ => write!(f, "error: {}\n{}", self.message, r),
                }
            }
            _ => {
                match self.nodes {
                    Some(ref n) => write!(f, "error: {}\n\n{}", self.message, n),
                    _ => write!(f, "error: {}", self.message),
                }
            }
        }
    }
}
